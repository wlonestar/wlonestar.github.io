<!DOCTYPE html>
<html
  lang="zh"
  dir="ltr"
  
><meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">


<title>计算机网络 01 应用层 | LoneStar&#39;s blog</title>

<meta name="generator" content="Hugo Eureka 0.9.3" />
<link rel="stylesheet" href="https://blog.wangjialei.xyz/css/eureka.min.9cec6350e37e534b0338fa9a085bf06855de3b0f2dcf857e792e5e97b07ea905d4d5513db554cbc26a9c3da622bae92d.css">
<script defer src="https://blog.wangjialei.xyz/js/eureka.min.fa9a6bf6d7a50bb635b4cca7d2ba5cf3dfb095ae3798773f1328f7950028b48c17d06276594e1b5f244a25a6c969a705.js"></script>













<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload"
  href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&amp;family=Noto&#43;Serif&#43;SC:wght@400;600;700&amp;display=swap"
  as="style" onload="this.onload=null;this.rel='stylesheet'">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/styles/stackoverflow-light.min.css"
   media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/highlight.min.js"
   crossorigin></script>
  <script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/languages/light.min.js"
     crossorigin></script>
<link rel="stylesheet" href="https://blog.wangjialei.xyz/css/highlightjs.min.2958991528e43eb6fc9b8c4f2b8e052f79c4010718e1d1e888a777620e9ee63021c2c57ec7417a3108019bb8c41943e6.css" media="print" onload="this.media='all';this.onload=null">


<script defer type="text/javascript" src="https://blog.wangjialei.xyz/js/fontawesome.min.d9ba21a4e7c7dbe0ba1f8b62ea1dda063fb92d88bd994ccb206ced4f4c9081fe517f9b61b57efd649e9edbdff33a2114.js"></script>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css"
   integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ"  media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js" 
  integrity="sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY"  crossorigin></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js"
   integrity="sha384-&#43;XBljXPPiv&#43;OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR"  crossorigin></script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true }
      ],
    });
  });
</script>


<script defer src="https://cdn.jsdelivr.net/npm/mermaid@8.14.0/dist/mermaid.min.js" 
  integrity="sha384-atOyb0FxAgN9LyAc6PEf9BjgwLISyansgdH8/VXQH8p2o5vfrRgmGIJ2Sg22L0A0"  crossorigin></script>


<link rel="icon" type="image/png" sizes="32x32" href="https://blog.wangjialei.xyz/images/favicon_huce974d41c22b18f52c9ea90a63a4b2a6_21741_32x32_fill_box_center_3.png">
<link rel="apple-touch-icon" sizes="180x180" href="https://blog.wangjialei.xyz/images/favicon_huce974d41c22b18f52c9ea90a63a4b2a6_21741_180x180_fill_box_center_3.png">

<meta name="description"
  content="计算机网络学习笔记">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
      "@type": "ListItem",
      "position": 1 ,
      "name":"文章",
      "item":"https://blog.wangjialei.xyz/posts/"},{
      "@type": "ListItem",
      "position": 2 ,
      "name":"计算机网络 01 应用层",
      "item":"https://blog.wangjialei.xyz/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-01-%E5%BA%94%E7%94%A8%E5%B1%82/"}]
}
</script>



<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://blog.wangjialei.xyz/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-01-%E5%BA%94%E7%94%A8%E5%B1%82/"
    },
    "headline": "计算机网络 01 应用层 | LoneStar\u0027s blog",
    "image": "https://mypic-1305118058.cos.ap-hongkong.myqcloud.com/img/2021-05-27.jpg",
    "datePublished": "2021-05-28T14:15:48+08:00",
    "dateModified": "2021-05-28T14:15:48+08:00",
    "wordCount":  432 ,
    "publisher": {
        "@type": "Person",
        "name": "lonestar",
        "logo": {
            "@type": "ImageObject",
            "url": "https://blog.wangjialei.xyz/images/favicon.png"
        }
        },
    "description": "计算机网络学习笔记"
}
</script><meta property="og:title" content="计算机网络 01 应用层 | LoneStar&#39;s blog" />
<meta property="og:type" content="article" />


<meta property="og:image" content="https://blog.wangjialei.xyz/images/favicon.png">


<meta property="og:url" content="https://blog.wangjialei.xyz/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-01-%E5%BA%94%E7%94%A8%E5%B1%82/" />



<meta property="og:description" content="计算机网络学习笔记" />



<meta property="og:locale" content="zh" />




<meta property="og:site_name" content="LoneStar&#39;s blog" />






<meta property="article:published_time" content="2021-05-28T14:15:48&#43;08:00" />


<meta property="article:modified_time" content="2021-05-28T14:15:48&#43;08:00" />



<meta property="article:section" content="posts" />


<meta property="article:tag" content="计算机网络" />





<meta property="og:see_also" content="https://blog.wangjialei.xyz/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-00-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/" />




  <body class="flex min-h-screen flex-col">
    <header
      class="min-h-16 pl-scrollbar bg-secondary-bg fixed z-50 flex w-full items-center shadow-sm"
    >
      <div class="mx-auto w-full max-w-screen-xl"><script>
    let storageColorScheme = localStorage.getItem("lightDarkMode")
    if (((storageColorScheme == 'Auto' || storageColorScheme == null) && window.matchMedia("(prefers-color-scheme: dark)").matches) || storageColorScheme == "Dark") {
        document.getElementsByTagName('html')[0].classList.add('dark')
    }
</script>
<nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0">
    <a href="/" class="me-6 text-primary-text text-xl font-bold">LoneStar&#39;s blog</a>
    <button id="navbar-btn" class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
        <i class="fas fa-bars"></i>
    </button>

    <div id="target"
        class="hidden block md:flex md:grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20">
        <div class="md:flex md:h-16 text-sm md:grow pb-4 md:pb-0 border-b md:border-b-0">
            <a href="/posts/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  selected-menu-item  me-4">文章</a>
            <a href="/categories/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">分类</a>
            <a href="/tags/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">标签</a>
            <a href="/series/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">系列</a>
            <a href="/#about" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">关于</a>
        </div>

        <div class="flex">
            <div class="relative pt-4 md:pt-0">
                <div class="cursor-pointer hover:text-eureka" id="lightDarkMode">
                    <i class="fas fa-adjust"></i>
                </div>
                <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id="is-open">
                </div>
                <div class="absolute flex flex-col start-0 md:start-auto end-auto md:end-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40"
                    id='lightDarkOptions'>
                    <span class="px-4 py-1 hover:text-eureka" name="Light">浅色</span>
                    <span class="px-4 py-1 hover:text-eureka" name="Dark">深色</span>
                    <span class="px-4 py-1 hover:text-eureka" name="Auto">自动</span>
                </div>
            </div>
        </div>
    </div>

    <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id="is-open-mobile">
    </div>

</nav>
<script>
    
    let element = document.getElementById('lightDarkMode')
    if (storageColorScheme == null || storageColorScheme == 'Auto') {
        document.addEventListener('DOMContentLoaded', () => {
            window.matchMedia("(prefers-color-scheme: dark)").addEventListener('change', switchDarkMode)
        })
    } else if (storageColorScheme == "Light") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'sun')
        element.firstElementChild.classList.add('fa-sun')
    } else if (storageColorScheme == "Dark") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'moon')
        element.firstElementChild.classList.add('fa-moon')
    }

    document.addEventListener('DOMContentLoaded', () => {
        getcolorscheme();
        switchBurger();
    });
</script>
</div>
    </header>
    <main class="grow pt-16">
        <div class="pl-scrollbar">
          <div class="mx-auto w-full max-w-screen-xl lg:px-4 xl:px-8">
  
  
  <div class="grid grid-cols-2 gap-4 lg:grid-cols-8 lg:pt-12">
    <div
      class=" bg-secondary-bg col-span-2 rounded px-6 py-8 lg:col-span-6"
    >
      <article class="prose">
  <h1 class="mb-4">计算机网络 01 应用层</h1>

  <div
  class="text-tertiary-text not-prose mt-2 flex flex-row flex-wrap items-center"
>
  <div class="me-6 my-2">
    <i class="fas fa-calendar me-1"></i>
    <span
      >2021-05-28</span
    >
  </div>
  <div class="me-6 my-2">
    <i class="fas fa-clock me-1"></i>
    <span>3分钟阅读时长</span>
  </div>

  
    <div class="me-6 my-2">
      <i class="fas fa-folder me-1"></i>
      
        <a href="https://blog.wangjialei.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="hover:text-eureka"
          >学习笔记</a
        >
      
    </div>
  

  
</div>


  
  
    <img src="https://mypic-1305118058.cos.ap-hongkong.myqcloud.com/img/2021-05-27.jpg" class="w-full" alt="Featured Image">
  

  <h2 id="应用层协议原理">应用层协议原理</h2>
<p>研发网络应用程序的核心是写出能够运行在不同的端系统和通过网络彼此通信的程序，例如运行在用户主机浏览器程序和 web 服务器主机上的 web 服务器程序。在各台主机中的这些程序可能都是类似的或相同的。</p>
<p>当研发新应用程序时，只需要编写将在多台端系统上运行的软件，不需要写在网络核心设备如路由器或链路层交换机上运行的软件。</p>
<p>网络核心设备并不在应用层上起作用，而仅在较低层起作用，特别是在网络层及下面层次起作用。这种基本设计方法，即将应用软件限制在端系统的方法，促进了大量的网络应用程序的迅速研发和部署。</p>
<p><img src="https://gitee.com/wjl-lab/mypic/raw/master/image-20210602143145308.png" alt="image-20210602143145308"></p>
<h3 id="网络应用程序体系结构">网络应用程序体系结构</h3>
<p>应用程序体系结构由应用程序研发者设计，规定了如何在各种端系统上组织该应用程序。</p>
<h4 id="客户-服务器体系结构client-server-architecture">客户-服务器体系结构（client-server architecture）</h4>
<p>在 <strong>C/S</strong> 结构中，有一个总是打开的主机称为服务器，服务于来自许多其他称为客户的主机的请求。典型的例子是 web 应用程序，总是打开的 web 服务器服务于来自浏览器（运行在客户主机上）的请求。当web服务器接收到来自某客户对某对象的请求时，它向该客户发送所请求的对象作为响应。 <strong>C/S</strong> 结构中客户相互之间不直接通信。</p>
<p><strong>C/S</strong> 结构的另一个特征是服务器具有固定的、周知的地址，该地址称为 IP 地址。因为该服务器具有固定的地址，并且该服务器总是打开的，客户总是能够通过向该服务器的 IP 地址发送分组来与其联系。</p>
<p><img src="https://gitee.com/wjl-lab/mypic/raw/master/image-20210602144549307.png" alt="image-20210602144549307"></p>
<h4 id="p2p体系结构p2p-architecture">P2P体系结构（P2P architecture）</h4>
<p>在 <strong>P2P</strong> 体系结构中，对位于数据中心的专用服务器有最小的（或者没有）依赖。应用程序在间断连接的主机对之间直接通信，这些主机对被称为对等方。这些对等方并不为服务提供商所有，为用户所有。因为这种对等方通信不必通过专门的服务器，该体系结构被称为对等方到对等方的。</p>
<p><img src="https://gitee.com/wjl-lab/mypic/raw/master/image-20210602144523386.png" alt="image-20210602144523386"></p>
<h3 id="进程通信">进程通信</h3>
<p>进行通信的实际上是<strong>进程</strong>（process）而不是程序。一个进程可以被认为是运行在端系统中的一个程序。当多个进程运行在相同的端系统上时，它们使用进程间通信机制相互通信。 在两个不同端系统上的进程，通过跨越计算机网络交换报文相互通信。发送进程生成并向网络中发送报文；接收进程接收这些报文并可能通过回送报文进行响应。</p>
<h4 id="客户和服务器进程">客户和服务器进程</h4>
<p>网络应用程序由成对的进程组成，这些进程通过网络相互发送报文。在 Web 应用程序中，一个客户浏览器进程与一台 Web 服务器进程交换报文。在一个 P2P 文件共享系统中，文件从一个对等方中的进程传输到另一个对等方中的进程。</p>
<p>对每对通信进程，我们通常将这两个进程之一标识为<strong>客户</strong>（client），而另一个进程标识为<strong>服务器</strong>（server）。 对于 Web 而言，浏览器是一个客户进程，Web 服务器是一台服务器进程。对于 P2P 文件共享，下载文件的对等方标识为客户，上载文件的对等方标识为服务器。 在 P2P 文件共享的某些应用中，一个进程能够既是客户又是服务器。</p>
<h4 id="进程与计算机网络之间的接口">进程与计算机网络之间的接口</h4>
<p>多数应用程序是由通信进程对组成，每对中的两个进程互相发送报文。从一个进程向另一个进程发送的报文必须通过下面的网络。进程通过一个称为<strong>套接字</strong>（socket）的软件接口向网络发送报文和从网络接收报文。</p>
<p><img src="https://gitee.com/wjl-lab/mypic/raw/master/image-20210602150047167.png" alt="image-20210602150047167"></p>
<p>套接字是同一台主机内应用层与运输层之间的接口。由于该套接字是建立网络应用程序的可编程接口，因此套接字也称为应用程序和网络之间的<strong>应用程序编程接口</strong>（Application Programming Interface, API）。</p>
<h3 id="进程寻址">进程寻址</h3>
<p>在一台主机上运行的进程为了向在另一台主机上运行的进程发送分组，接收进程需要有一个地址。为了标识该接收进程，需要定义两种信息：①主机的地址；②在目的主机中指定接收进程的标识符。</p>
<p>在因特网中，主机由其 <strong>IP 地址</strong>（IP address）标识。除了知道报文发送目的地的主机地址外，发送进程还必须指定运行在接收主机上的接收进程（更具体地说，接收套接字）。因为一般而言一台主机能够运行许多网络应用，这些信息是需要的。目的地<strong>端口号</strong>（port number）用于这个目的。</p>
<h3 id="因特网提供的运输服务">因特网提供的运输服务</h3>
<h4 id="tcp-服务">TCP 服务</h4>
<p>TCP服务模型包括面向连接服务和可靠数据传输服务。当某个应用程序调用 TCP 作为其运输协议时，该应用程序就能获得来自 TCP 的这两种服务。</p>
<ul>
<li>面向连接的服务：在应用层数据报文开始流动之前，TCP让客户和服务器互相交换运输层控制信息。这个所谓的握手过程提醒客户和服务器，让它们为大量分组的到来做好准备。在握手阶段后，一个<strong>TCP连接</strong>（TCP connection ）就在两个进程的套接字之间建立了。这条连接是全双工的，即连接双方的进程可以在此连接 上同时进行报文收发。当应用程序结束报文发送时，必须拆除该连接。</li>
<li>可靠的数据传送服务：通信进程能够依靠TCP，无差错、按适当顺序交付所有发送的数据。当应用程序的一端将字节流传进套接字时，它能够依靠TCP将相同的字节流交付给接收方的套接字，而没有字节的丢失和冗余。</li>
</ul>
<h4 id="udp-服务">UDP 服务</h4>
<p>UDP是一种不提供不必要服务的轻量级运输协议，它仅提供最小服务。UDP是无连接的，因此在两个进程通信前没有握手过程。UDP协议提供一种不可靠数据传送服务，也 就是说，当进程将一个报文发送进UDP套接字时，UDP协议并不保证该报文将到达接收进程。不仅如此，到达接收进程的报文也可能是乱序到达的。</p>
<h3 id="应用层协议">应用层协议</h3>
<p><strong>应用层协议</strong>（application-layer protocol）定义了运行在不同端系统上的应用程序进程如何相互传递报文。</p>
<ul>
<li>交换的报文类型</li>
<li>各种报文类型的语法</li>
<li>字段的语义</li>
<li>确定一个进程何时以及如何发送报文</li>
</ul>
<h2 id="web-和-http">Web 和 HTTP</h2>
<h3 id="http-概况">HTTP 概况</h3>
<p>Web 的应用层协议是<strong>超文本传输协议</strong>（HyperText Transfer Protocol, HTTP），它是 Web 的核心。HTTP 由两个程序实现：一个客户程序和一个服务器程序。客户程序和服务器程序运行在不同的端系统中，通过交换 HTTP 报文进行会话。HTTP 定义了这些报文的结构以及客户和服务器进行报文交换的方式。</p>
<p><strong>Web页面</strong>（Web page）（也叫文档）是由对象组成的。一个<strong>对象</strong>（object）只是一个文件，诸如一个HTML文件、一个JPEG图形、一个Java小程序或一个视频片段这样的文件，且它们可通过一个URL地址寻址。多数Web页面含有一个 <strong>HTML基本文件</strong>（base HTML file）以及几个引用对象。</p>
<p>HTML基本文件通过对象的 URL 地址引用页面中的其他对象。每个URL地址由两部分组成：存放对象的服务器主机名和对象的路径名。例如，URL 地址 <code>http://www.someSchool.edu/someDepartment/picture.gif</code>，其中的 <code>www.someSchool.edu</code> 就是主机名，<code>/someDepartment/picture.gif</code> 就是路径名。Web服务器（Webserver）实现了 HTTP 的服务器端，它用于存储 Web 对象，每个对象由 URL 寻 址。</p>
<p>HTTP 定义了 Web 客户向 Web 服务器请求 Web 页面的方式，以及服务器向客户传送 Web 页面的方式。当用户请求一个 Web 页面（如点击一个超链接）时，浏览器向服务器发出对该页面中所包含对象的 HTTP 请求报文，服务器接收到请求并用包含这些对象的 HTTP 响应报文进行响应。</p>
<p><img src="https://gitee.com/wjl-lab/mypic/raw/master/image-20210605154120742.png" alt="image-20210605154120742"></p>
<p>因为 HTTP 服务器并不保存关于客户的任何信息，所以说 HTTP 是一个<strong>无状态协议</strong>（stateless protocol）。</p>
<h3 id="非持续连接和持续连接">非持续连接和持续连接</h3>
<h4 id="采用非持续连接的-http">采用非持续连接的 HTTP</h4>
<p>在非持续连接情况下，从服务器向客户传送一个 Web 页面的步骤。</p>
<p>假设该页面含有一个 HTML 基本文件和10个 JPEG 图形，并且这11个对象位于同一台服务器上。进 一步假设该 HTML 文件的 URL 为：<code>http://www.someSchool.edu/someDepartment/home.index</code></p>
<ol>
<li>
<p>HTTP 客户进程在端口号80发起一个到服务器 <code>www.someSchool.edu</code> 的 TCP 连接，该端口号是 HTTP 的默认端口。在客户和服务器上分别有一个套接字与该连接相关联。</p>
</li>
<li>
<p>HTTP 客户经它的套接字向该服务器发送一个 HTTP 请求报文。请求报文中包含了路径名 <code>/someDepartment/home.index</code> 。</p>
</li>
<li>
<p>HTTP 服务器进程经它的套接字接收该请求报文，从其存储器（RAM或磁盘）中检索出对象 <code>www.someSchool.edu/someDepartment/home.index</code> ，在一个 HTTP 响应报文中封装对象，并通过其套接字向客户发送响应报文。</p>
</li>
<li>
<p>HTTP 服务器进程通知 TCP 断开该 TCP 连接。（但是直到TCP确认客户已经完整地收到响应报文为止，它才会实际中断连接。）</p>
</li>
<li>
<p>HTTP 客户接收响应报文，TCP 连接关闭。该报文指出封装的对象是一个 HTML 文件，客户从响应报文中提取出该文件，检査该 HTML 文件，得到对10个 JPEG 图形的引用。</p>
</li>
<li>
<p>对每个引用的JPEG图形对象重复前4个步骤。</p>
</li>
</ol>
<p>每个 TCP 连接在服务器发送一个对象后关闭，即该连接并不为其他的对象而持续下来。每个 TCP 连接只传输一个请求报文和一个响应报文。</p>
<h4 id="采用持续连接的-http">采用持续连接的 HTTP</h4>
<p>在采用 <code>HTTP 1.1</code> 持续连接的情况下，服务器在发送响应后保持该 TCP 连接打开。在相同的客户与服务器之间，后续的请求和响应报文能够通过相同的连接进行传送。</p>
<h3 id="用户与服务器的交互cookie">用户与服务器的交互：cookie</h3>
<p>HTTP 服务器是无状态的，这简化了服务器的设计，并且允许工程师们去开发可以同时处理数以千计的 TCP 连接的高性能Web服务器。然而一个 Web 站点通常希望能够识别用户，可能是因为服务器希望限制用户的访问，或者因为它希望把内容与用户身份联系起来。为此，HTTP 使用了 cookie，它允许站点对用户进行跟踪。</p>
<p><img src="https://gitee.com/wjl-lab/mypic/raw/master/image-20210605162219676.png" alt="image-20210605162219676"></p>
<h3 id="web-缓存">web 缓存</h3>
<p><strong>Web缓存器</strong>（Web cache）也叫<strong>代理服务器</strong>（proxy server），它是能够代表初始 Web 服务器来满足 HTTP 请求的网络实体。Web 缓存器有自己的磁盘存储空间， 并在存储空间中保存最近请求过的对象的副本。</p>
<p><img src="https://gitee.com/wjl-lab/mypic/raw/master/image-20210605162333931.png" alt="image-20210605162333931"></p>
<p>假设浏览器正在请求对象 <code>http://www.someschool.edu/campus.gif</code> ，将会发生如下情况：</p>
<ol>
<li>
<p>浏览器创建一个到 Web 缓存器客户初始服务器，并向 Web 缓存器中的对象发送一个HTTP请求</p>
</li>
<li>
<p>Web 缓存器进行检查，看看本地是否存储了该对象副本。如果有，Web 缓存器就向客户浏览器用HTTP响应报文返回该对象</p>
</li>
<li>
<p>如果 Web 缓存器中没有该对象，它就打开一个与该对象的初始服务器（即 <code>www.someschool.edu</code>）的 TCP 连接。Web 缓存器则在这个缓存器到服务器的 TCP 连接上发送一个对该对象的 HTTP 请求。在收到该请求后，初始服务器向该 Web 缓存器发送具有该对象的HTTP响应</p>
</li>
<li>
<p>当 Web 缓存器接收到该对象时，它在本地存储空间存储一份副本，并向客户的浏览器用 HTTP 响应报文发送该副本（通过现有的客户浏览器和 Web 缓存器之间的 TCP 连接）</p>
</li>
</ol>
<p>首先，Web 缓存器可以大大减少对客户请求的响应时间，特别是当客户与初始服务器之间的瓶颈带宽远低于客户与 Web 缓存器之 间的瓶颈带宽时更是如此。如果在客户与 Web 缓存器之间有一个高速连接（情况常常如此），并且如果用户所请求的对象在 Web 缓存器上，则 Web 缓存器可以迅速将该对象交付给用户。</p>
<p>其次，Web 缓存器能够大大减少一个机构的接入链路到因特网的通信量。通过减少通信量，该机构（如一家公司或者一所大学）就不必急于增加带宽，因此降低了费用。此外，Web缓存器能从整体上大大减低因特网上的 Web 流量，从而改善了所有应用的性能。</p>
<h3 id="条件-get-方法">条件 GET 方法</h3>
<p>尽管高速缓存能减少用户感受到的响应时间，但也引入了一个新的问题，即存放在缓存器中的对象副本可能是陈旧的。换句话说，保存在服务器中的对象自该副本缓存在客户上以后可能已经被修改了。</p>
<p>HTTP 利用<strong>条件GET方法</strong>（conditional GET）允许缓存器证实它的对象是最新的。</p>
<p>一个请求报文：</p>
<pre><code>GET /fruit/kiwi.gif HTTP/1.1
Host: www.exotiquecuisine.com
If-modified-since: Wed, 9 Sep 2015 09:23:24
</code></pre>
<p>该条件报文告诉服务器，仅当自指定日期之后该对象被修改过，才发送对象。</p>
<h2 id="因特网中的电子邮件">因特网中的电子邮件</h2>
<p><strong>用户代理</strong>（user agent）允许用户阅读、回复、转发、保存和撰写报文</p>
<p><strong>邮件服务器</strong>（mail server）形成电子邮件体系结构的核心，每个接收方在某个邮件服务器上有一个<strong>邮箱</strong>（mailbox）</p>
<p><img src="https://gitee.com/wjl-lab/mypic/raw/master/image-20210606143016891.png" alt="image-20210606143016891"></p>
<h3 id="smtp">SMTP</h3>
<p><strong>SMTP</strong>（Simple Mail Transfer Protocol）简单邮件传输协议是因特网电子邮件的核心。</p>
<p>Alice 向 Bob 发送一条报文：</p>
<p><img src="https://gitee.com/wjl-lab/mypic/raw/master/image-20210914211626604.png" alt="image-20210914211626604"></p>
<h3 id="与-http-的对比">与 HTTP 的对比</h3>
<p>HTTP 主要是一个<strong>拉协议</strong>（pull protocol），某些人在 web 服务器上装载信息，用户使用 HTTP 从该服务器拉取这些信息， TCP 连接是由想接收文件的机器发起的。</p>
<p>SMTP 基本上是一个<strong>推协议</strong>（push protocol），发送邮件服务器把文件推向接收邮件服务器， TCP 连接是由要发送文件的机器发起的。</p>
<h2 id="dns因特网的目录服务">DNS：因特网的目录服务</h2>
<p>主机名几乎没有提供关于主机在因特网中位置的信息。</p>
<p>主机可以使用 <strong>IP 地址</strong>进行标识。</p>
<h3 id="dns-提供的服务">DNS 提供的服务</h3>
<p><strong>域名系统</strong>（Domain Name System， DNS）是：</p>
<ol>
<li>一个由分层的 <strong>DNS 服务器</strong>（DNS server）实现的分布式数据库</li>
<li>一个使得主机能够查询分布式数据库的应用层协议</li>
</ol>
<p>DNS 服务器通常是运行 BIND（Berkeley Internet Name Domain）软件的 UNIX 机器，DNS 协议运行在 UDP 上，使用 53 号端口。</p>
<p>DNS 通常是由其他应用层协议所使用的，包括 HTTP、SMTP 和 FTP，将用户提供的主机名解析为 IP 地址。</p>
<h3 id="dns-工作机理概述">DNS 工作机理概述</h3>
<p>从用户主机上调用应用程序的角度看，DNS 是一个提供简单、直接的转换服务的黑盒子。但事实上，实现这个服务的黑盒子非常复杂，由分布于全球的大量 DNS 服务器以及定义了 DNS 服务器与查询主机通信方式的应用层协议组成。</p>
<h4 id="分布式层次数据库">分布式、层次数据库</h4>
<p>DNS 使用了大量的 DNS 服务器，它们以层次方式组织，并且分布在全世界范围内。</p>
<ul>
<li>
<p><strong>根 DNS 服务器</strong>：有400多个根名字服务器遍及全世界，根名字服务器提供 TLD 服务器的 IP 地址</p>
</li>
<li>
<p><strong>顶级域（Top-level Domain, TLD）</strong>：对于每个顶级域（com, org, net, edu, gov）和所有国家的顶级域（uk, cn, ca, fr, jp），都有 TLD 服务器（或服务器集群），TLD 服务器提供了权威 DNS 服务器的 IP 地址</p>
</li>
<li>
<p><strong>权威 DNS 服务器</strong>：在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问的 DNS 记录，这些记录将这些主机的名字映射为 IP 地址。</p>
</li>
</ul>
<p><img src="https://gitee.com/wjl-lab/mypic/raw/master/image-20210606151411843.png" alt="image-20210606151411843"></p>
<h4 id="dns-缓存">DNS 缓存</h4>
<p>为了改善时延性能并减少在因特网上到处传输的 DNS 报文数量， DNS 广泛使用了缓存技术。</p>
<p>DNS缓存的原理：在一个请求链中，当某 DNS 服务器接收一个 DNS 回答（包含某主机名到 IP 地址的映射）时，它能将映射缓存在本地存储器中。</p>
<h2 id="p2p-文件分发">P2P 文件分发</h2>
<p>使用 P2P 体系结构，对总是打开的基础设施服务器有最小的依赖。</p>
<p><img src="https://gitee.com/wjl-lab/mypic/raw/master/image-20210609111612549.png" alt="image-20210609111612549"></p>

</article>


      
        <div class="my-4">
    
    <a href="https://blog.wangjialei.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 me-2 hover:text-eureka">#计算机网络</a>
    
</div>
      

      



      

      
  <div
    class="-mx-2 mt-4 flex flex-col border-t px-2 pt-4 md:flex-row md:justify-between"
  >
    <div>
      
        <span class="text-primary-text block font-bold"
          >上一页</span
        >
        <a href="https://blog.wangjialei.xyz/posts/%E5%BE%AE%E7%94%B5%E5%BD%B1%E9%9D%92%E8%8A%92%E5%B9%95%E5%90%8E%E6%95%85%E4%BA%8B/" class="block">微电影《青芒》幕后故事</a>
      
    </div>
    <div class="mt-4 md:mt-0 md:text-right">
      
        <span class="text-primary-text block font-bold">下一页</span>
        <a href="https://blog.wangjialei.xyz/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-00-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/" class="block">计算机网络 00 计算机网络概述</a>
      
    </div>
  </div>


      



    </div>
    
      <div class="col-span-2">
        
        
          <div
  class="
    bg-primary-bg
   prose sticky top-16 z-10 hidden px-6 py-4 lg:block"
>
  <h3>本页内容</h3>
</div>
<div
  class="sticky-toc  hidden px-6 pb-6 lg:block"
>
  <nav id="TableOfContents">
  <ul>
    <li><a href="#应用层协议原理">应用层协议原理</a>
      <ul>
        <li><a href="#网络应用程序体系结构">网络应用程序体系结构</a>
          <ul>
            <li><a href="#客户-服务器体系结构client-server-architecture">客户-服务器体系结构（client-server architecture）</a></li>
            <li><a href="#p2p体系结构p2p-architecture">P2P体系结构（P2P architecture）</a></li>
          </ul>
        </li>
        <li><a href="#进程通信">进程通信</a>
          <ul>
            <li><a href="#客户和服务器进程">客户和服务器进程</a></li>
            <li><a href="#进程与计算机网络之间的接口">进程与计算机网络之间的接口</a></li>
          </ul>
        </li>
        <li><a href="#进程寻址">进程寻址</a></li>
        <li><a href="#因特网提供的运输服务">因特网提供的运输服务</a>
          <ul>
            <li><a href="#tcp-服务">TCP 服务</a></li>
            <li><a href="#udp-服务">UDP 服务</a></li>
          </ul>
        </li>
        <li><a href="#应用层协议">应用层协议</a></li>
      </ul>
    </li>
    <li><a href="#web-和-http">Web 和 HTTP</a>
      <ul>
        <li><a href="#http-概况">HTTP 概况</a></li>
        <li><a href="#非持续连接和持续连接">非持续连接和持续连接</a>
          <ul>
            <li><a href="#采用非持续连接的-http">采用非持续连接的 HTTP</a></li>
            <li><a href="#采用持续连接的-http">采用持续连接的 HTTP</a></li>
          </ul>
        </li>
        <li><a href="#用户与服务器的交互cookie">用户与服务器的交互：cookie</a></li>
        <li><a href="#web-缓存">web 缓存</a></li>
        <li><a href="#条件-get-方法">条件 GET 方法</a></li>
      </ul>
    </li>
    <li><a href="#因特网中的电子邮件">因特网中的电子邮件</a>
      <ul>
        <li><a href="#smtp">SMTP</a></li>
        <li><a href="#与-http-的对比">与 HTTP 的对比</a></li>
      </ul>
    </li>
    <li><a href="#dns因特网的目录服务">DNS：因特网的目录服务</a>
      <ul>
        <li><a href="#dns-提供的服务">DNS 提供的服务</a></li>
        <li><a href="#dns-工作机理概述">DNS 工作机理概述</a>
          <ul>
            <li><a href="#分布式层次数据库">分布式、层次数据库</a></li>
            <li><a href="#dns-缓存">DNS 缓存</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#p2p-文件分发">P2P 文件分发</a></li>
  </ul>
</nav>
</div>
<script>
  window.addEventListener("DOMContentLoaded", () => {
    enableStickyToc();
  });
</script>

        
      </div>
    

    
    
      <div
        class=" bg-secondary-bg prose col-span-2 rounded p-6 lg:col-span-6"
      >
        <h3>相关</h3>
        
          <a href="https://blog.wangjialei.xyz/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-00-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/" class="no-underline">计算机网络 00 计算机网络概述</a>
          <br />
        
      </div>
    
  </div>

  
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        hljs.highlightAll();
      });
    </script>

          </div>
        </div>
      
    </main>
    <footer class="pl-scrollbar">
      <div class="mx-auto w-full max-w-screen-xl"><div class="text-center p-6 pin-b">
    <p class="text-sm text-tertiary-text">&copy; 2021 <a href="https://blog.wangjialei.xyz/">Wang Jialei</a>
 &middot;  Powered by the <a href="https://github.com/wangchucheng/hugo-eureka" class="hover:text-eureka">Eureka</a> theme for <a href="https://gohugo.io" class="hover:text-eureka">Hugo</a></p>
</div></div>
    </footer>
  </body>
</html>
