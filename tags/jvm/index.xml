<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JVM on LoneStar&#39;s blog</title>
    <link>https://blog.wangjialei.xyz/tags/jvm/</link>
    <description>Recent content in JVM on LoneStar&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>&amp;copy; 2021 &lt;a href=&#34;https://blog.wangjialei.xyz/&#34;&gt;Wang Jialei&lt;/a&gt;
</copyright>
    <lastBuildDate>Sat, 20 Mar 2021 17:20:52 +0800</lastBuildDate><atom:link href="https://blog.wangjialei.xyz/tags/jvm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java虚拟机 03 垃圾收集器</title>
      <link>https://blog.wangjialei.xyz/posts/java%E8%99%9A%E6%8B%9F%E6%9C%BA-03-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</link>
      <pubDate>Sat, 20 Mar 2021 17:20:52 +0800</pubDate>
      
      <guid>https://blog.wangjialei.xyz/posts/java%E8%99%9A%E6%8B%9F%E6%9C%BA-03-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</guid>
      <description>垃圾收集 当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，就需要对内存的动态分配与内存回收技术实施必要的监控和调节。
Java堆和方法区不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存。
对象已死 垃圾收集器在对堆进行回收前，先要确定存放在堆中的对象实例有哪些还“存活着”，哪些已经“死去”。
引用计数算法 计数算法：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不可能再被使用的。
Java语言中没有选用引用计数算法来管理内存，因为它很难解决对象之间的相互循环引用的问题。
引用计数算法的缺陷
public class ReferenceCountingGC {public Object instance = null;private static final int _1MB = 1024 * 1024;private final byte[] bigSize = new byte[2 * _1MB];public void testGC() {ReferenceCountingGC objA = new ReferenceCountingGC();ReferenceCountingGC objB = new ReferenceCountingGC();objA.</description>
    </item>
    
    <item>
      <title>Java虚拟机 02 Java内存区域</title>
      <link>https://blog.wangjialei.xyz/posts/java%E8%99%9A%E6%8B%9F%E6%9C%BA-02-java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</link>
      <pubDate>Sat, 20 Mar 2021 14:02:26 +0800</pubDate>
      
      <guid>https://blog.wangjialei.xyz/posts/java%E8%99%9A%E6%8B%9F%E6%9C%BA-02-java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</guid>
      <description>自动内存管理 在虚拟机的自动内存管理机制下，Java不需要为每一个new操作去写配对的delete/free代码，而且不容易出现内存泄漏和内存溢出问题。但一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，排查错误就会很难。
运行时数据区域 Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。
程序计数器 程序计数器的功能可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。
Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，因此为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，线程私有。
如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果线程正在执行的是Native方法，这个计数器值为空，此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。
Java虚拟机栈 虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行时都会同时创建一个栈帧用于存储局部变量表、操作栈、动态链接、方法出口等。每个方法被调用直至执行完成的过程中，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</description>
    </item>
    
    <item>
      <title>Java虚拟机 01 走近Java</title>
      <link>https://blog.wangjialei.xyz/posts/java%E8%99%9A%E6%8B%9F%E6%9C%BA-01-%E8%B5%B0%E8%BF%91java/</link>
      <pubDate>Sat, 20 Mar 2021 08:54:55 +0800</pubDate>
      
      <guid>https://blog.wangjialei.xyz/posts/java%E8%99%9A%E6%8B%9F%E6%9C%BA-01-%E8%B5%B0%E8%BF%91java/</guid>
      <description>Java技术体系 Sun官方定义的Java技术体系包括：
Java程序设计语言 各种硬件平台上的Java虚拟机 Class文件格式 Java API类库 来自商业机构和开源社区的第三方Java类库 JDK（Java Development Kit）包括Java程序设计语言、Java虚拟机、Java API类库三部分，JDK是用于支持Java程序开发的最小环境。</description>
    </item>
    
  </channel>
</rss>
